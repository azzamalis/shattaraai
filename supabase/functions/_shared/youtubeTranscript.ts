/**
 * YouTube Transcript Extraction Module
 * 
 * Provides multiple methods for extracting YouTube transcripts with automatic fallback:
 * 1. Supadata API (most reliable, handles all caption types)
 * 2. Native YouTube timedtext API (free but less reliable)
 * 
 * Each method returns timestamped segments when available for better context preservation.
 */

import { fetchWithRetry, logRetryMetrics } from './retryUtils.ts';

// Transcript segment with timestamp information
export interface TranscriptSegment {
  text: string;
  startTime: number;  // seconds
  duration: number;   // seconds
  endTime: number;    // seconds (computed)
}

// Result from transcript extraction
export interface TranscriptResult {
  transcript: string;           // Full text transcript
  segments: TranscriptSegment[]; // Timestamped segments if available
  source: 'supadata' | 'youtube_timedtext' | 'description' | 'none';
  language: string;
  isAutoGenerated: boolean;
  metadata: {
    extractionTime: number;     // ms
    segmentCount: number;
    characterCount: number;
    method: string;
    error?: string;
  };
}

// Supadata API response format
interface SupadataTranscriptResponse {
  content: Array<{
    text: string;
    offset: number;   // milliseconds
    duration: number; // milliseconds
  }>;
  lang: string;
  availableLangs: string[];
}

/**
 * Extract transcript using Supadata API
 * More reliable than native YouTube API, handles all caption types
 */
async function extractWithSupadata(
  videoId: string, 
  apiKey: string,
  preferredLang: string = 'en'
): Promise<TranscriptResult | null> {
  const startTime = Date.now();
  
  try {
    console.log(`[Supadata] Attempting transcript extraction for video: ${videoId}`);
    
    const response = await fetchWithRetry(
      `https://api.supadata.ai/v1/youtube/transcript?videoId=${videoId}&lang=${preferredLang}`,
      {
        method: 'GET',
        headers: {
          'x-api-key': apiKey,
          'Accept': 'application/json'
        }
      },
      {
        maxRetries: 2,
        timeoutMs: 30000,
        retryableStatusCodes: [408, 429, 500, 502, 503, 504],
        onRetry: (attempt, error) => {
          console.log(`[Supadata] Retry ${attempt}: ${error.message}`);
        }
      }
    );

    const extractionTime = Date.now() - startTime;
    logRetryMetrics('supadata_transcript', 1, response.ok, extractionTime);

    if (!response.ok) {
      const errorText = await response.text().catch(() => 'Unknown error');
      console.log(`[Supadata] Failed with status ${response.status}: ${errorText}`);
      return null;
    }

    const data: SupadataTranscriptResponse = await response.json();
    
    if (!data.content || data.content.length === 0) {
      console.log('[Supadata] No content returned');
      return null;
    }

    // Convert to standardized segments
    const segments: TranscriptSegment[] = data.content.map(item => ({
      text: item.text.trim(),
      startTime: item.offset / 1000,      // Convert ms to seconds
      duration: item.duration / 1000,
      endTime: (item.offset + item.duration) / 1000
    }));

    // Build full transcript
    const transcript = segments
      .map(s => s.text)
      .filter(t => t.length > 0)
      .join(' ');

    console.log(`[Supadata] Successfully extracted ${segments.length} segments, ${transcript.length} chars`);

    return {
      transcript,
      segments,
      source: 'supadata',
      language: data.lang || preferredLang,
      isAutoGenerated: false, // Supadata usually returns manual captions when available
      metadata: {
        extractionTime,
        segmentCount: segments.length,
        characterCount: transcript.length,
        method: 'supadata_api'
      }
    };
  } catch (error) {
    console.error('[Supadata] Extraction error:', error);
    return null;
  }
}

/**
 * Parse YouTube timedtext XML response
 */
function parseTimedTextXml(xml: string): TranscriptSegment[] {
  const segments: TranscriptSegment[] = [];
  
  try {
    // Match all text elements with start and dur attributes
    const textPattern = /<text\s+start="([^"]+)"\s+dur="([^"]+)"[^>]*>([^<]*)<\/text>/g;
    let match;
    
    while ((match = textPattern.exec(xml)) !== null) {
      const startTime = parseFloat(match[1]);
      const duration = parseFloat(match[2]);
      let text = match[3]
        .replace(/&amp;/g, '&')
        .replace(/&lt;/g, '<')
        .replace(/&gt;/g, '>')
        .replace(/&quot;/g, '"')
        .replace(/&#39;/g, "'")
        .replace(/\n/g, ' ')
        .trim();
      
      if (text.length > 0) {
        segments.push({
          text,
          startTime,
          duration,
          endTime: startTime + duration
        });
      }
    }
  } catch (error) {
    console.error('[TimedText] XML parsing error:', error);
  }
  
  return segments;
}

/**
 * Extract transcript using native YouTube timedtext API
 * Free but less reliable, may not work for all videos
 */
async function extractWithYouTubeTimedText(
  videoId: string,
  preferredLang: string = 'en'
): Promise<TranscriptResult | null> {
  const startTime = Date.now();
  
  try {
    console.log(`[TimedText] Attempting transcript extraction for video: ${videoId}`);
    
    // Try manual captions first
    const endpoints = [
      `https://www.youtube.com/api/timedtext?lang=${preferredLang}&v=${videoId}`,
      `https://www.youtube.com/api/timedtext?lang=${preferredLang}&v=${videoId}&tlang=${preferredLang}`,
      `https://www.youtube.com/api/timedtext?lang=en&v=${videoId}`,
      `https://www.youtube.com/api/timedtext?lang=en&v=${videoId}&tlang=en`
    ];
    
    for (const url of endpoints) {
      try {
        const response = await fetchWithRetry(
          url,
          { method: 'GET' },
          {
            maxRetries: 1,
            timeoutMs: 15000,
            retryableStatusCodes: [408, 429, 500, 502, 503, 504]
          }
        );
        
        if (response.ok) {
          const xml = await response.text();
          
          if (xml && xml.includes('<text')) {
            const segments = parseTimedTextXml(xml);
            
            if (segments.length > 0) {
              const transcript = segments.map(s => s.text).join(' ');
              const extractionTime = Date.now() - startTime;
              
              logRetryMetrics('youtube_timedtext', 1, true, extractionTime);
              
              console.log(`[TimedText] Successfully extracted ${segments.length} segments from ${url}`);
              
              return {
                transcript,
                segments,
                source: 'youtube_timedtext',
                language: preferredLang,
                isAutoGenerated: url.includes('tlang='),
                metadata: {
                  extractionTime,
                  segmentCount: segments.length,
                  characterCount: transcript.length,
                  method: url.includes('tlang=') ? 'timedtext_auto' : 'timedtext_manual'
                }
              };
            }
          }
        }
      } catch (e) {
        console.log(`[TimedText] Endpoint ${url} failed:`, e.message);
      }
    }
    
    console.log('[TimedText] No transcript found from any endpoint');
    return null;
  } catch (error) {
    console.error('[TimedText] Extraction error:', error);
    return null;
  }
}

/**
 * Main transcript extraction function with fallback chain
 * 
 * Order of attempts:
 * 1. Supadata API (if API key available)
 * 2. YouTube timedtext API
 * 3. Return description as fallback
 */
export async function extractYouTubeTranscript(
  videoId: string,
  options: {
    supadataApiKey?: string;
    preferredLang?: string;
    fallbackDescription?: string;
  } = {}
): Promise<TranscriptResult> {
  const { 
    supadataApiKey, 
    preferredLang = 'en',
    fallbackDescription = ''
  } = options;
  
  const startTime = Date.now();
  let lastError: string | undefined;
  
  // Method 1: Try Supadata API first (most reliable)
  if (supadataApiKey) {
    const supadataResult = await extractWithSupadata(videoId, supadataApiKey, preferredLang);
    if (supadataResult && supadataResult.transcript.length > 50) {
      return supadataResult;
    }
    lastError = 'Supadata returned insufficient content';
  }
  
  // Method 2: Try native YouTube timedtext API
  const timedTextResult = await extractWithYouTubeTimedText(videoId, preferredLang);
  if (timedTextResult && timedTextResult.transcript.length > 50) {
    return timedTextResult;
  }
  lastError = lastError || 'YouTube timedtext returned insufficient content';
  
  // Method 3: Fall back to description
  if (fallbackDescription && fallbackDescription.length > 0) {
    console.log('[Transcript] Falling back to video description');
    return {
      transcript: fallbackDescription,
      segments: [],
      source: 'description',
      language: preferredLang,
      isAutoGenerated: false,
      metadata: {
        extractionTime: Date.now() - startTime,
        segmentCount: 0,
        characterCount: fallbackDescription.length,
        method: 'description_fallback',
        error: lastError
      }
    };
  }
  
  // No transcript available
  console.log('[Transcript] No transcript available from any source');
  return {
    transcript: '',
    segments: [],
    source: 'none',
    language: preferredLang,
    isAutoGenerated: false,
    metadata: {
      extractionTime: Date.now() - startTime,
      segmentCount: 0,
      characterCount: 0,
      method: 'none',
      error: lastError || 'No transcript sources available'
    }
  };
}

/**
 * Extract chapter-specific transcripts from timestamped segments
 */
export function extractChapterTranscripts(
  segments: TranscriptSegment[],
  chapters: Array<{ title: string; startTime: number; endTime?: number }>
): Array<{ title: string; startTime: number; endTime?: number; transcript: string }> {
  if (segments.length === 0 || chapters.length === 0) {
    return chapters.map(ch => ({ ...ch, transcript: '' }));
  }
  
  return chapters.map((chapter, index) => {
    const chapterEnd = chapter.endTime ?? 
      (index < chapters.length - 1 ? chapters[index + 1].startTime : Infinity);
    
    // Find segments that fall within this chapter's time range
    const chapterSegments = segments.filter(seg => 
      seg.startTime >= chapter.startTime && seg.startTime < chapterEnd
    );
    
    const transcript = chapterSegments.map(s => s.text).join(' ');
    
    return {
      ...chapter,
      endTime: chapterEnd === Infinity ? undefined : chapterEnd,
      transcript
    };
  });
}
